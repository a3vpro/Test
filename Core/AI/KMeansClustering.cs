using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using Microsoft.ML;
using Microsoft.ML.Data;
using Microsoft.ML.Trainers;
using VisionNet.Core.Dawing;

namespace VisionNet.Core.AI
{
    /// <summary>
    /// Implements K-Means clustering using ML.NET over 2D points with context.
    /// </summary>
    /// <typeparam name="T">Type of additional context stored with each point.</typeparam>
    public class KMeansClustering<T>
    {
        /// <summary>
        /// Gets or sets the collection of data points that will be clustered, including their associated context.
        /// </summary>
        /// <remarks>Each point must contain valid <see cref="PointF"/> coordinates and any contextual payload required by consumers.</remarks>
        public List<PointFWithContext<T>> Points { get; set; } = new List<PointFWithContext<T>>();

        /// <summary>
        /// Gets or sets the number of clusters the K-Means algorithm should produce.
        /// </summary>
        /// <remarks>Values must be greater than or equal to 1 and should not exceed the total number of points provided.</remarks>
        public int ClusterCount { get; set; } = 3;

        /// <summary>
        /// Gets or sets the maximum number of iterations the training procedure should execute before stopping.
        /// </summary>
        /// <remarks>Applies to both full-batch and mini-batch executions; values must be positive.</remarks>
        public int MaxIterations { get; set; } = 100;

        /// <summary>
        /// Gets the clusters generated by the most recent execution, where each cluster contains the original points and their context.
        /// </summary>
        /// <remarks>The list is repopulated every time <see cref="Execute"/> or <see cref="ExecuteMiniBatch(int)"/> runs.</remarks>
        public List<List<PointFWithContext<T>>> Clusters { get; private set; } = new List<List<PointFWithContext<T>>>();

        /// <summary>
        /// Adds a single point with context to the collection that will be clustered on the next execution.
        /// </summary>
        /// <param name="point">The point, including coordinates and contextual data; must not be <c>null</c>.</param>
        public void AddPoint(PointFWithContext<T> point) => Points.Add(point);

        /// <summary>
        /// Removes all stored points and clears any previously generated clusters.
        /// </summary>
        public void Clear()
        {
            Points.Clear();
            Clusters.Clear();
        }

        /// <summary>
        /// Executes K-Means clustering via ML.NET.
        /// </summary>
        /// <exception cref="InvalidOperationException">
        /// Thrown when <see cref="ClusterCount"/> is less than 1 or when there are fewer points than clusters.
        /// </exception>
        public void Execute()
        {
            if (ClusterCount < 1)
                throw new InvalidOperationException("ClusterCount must be at least 1.");
            if (Points.Count < ClusterCount)
                throw new InvalidOperationException("Not enough points to form the requested number of clusters.");

            var mlContext = new MLContext();
            // Prepare data
            var data = mlContext.Data.LoadFromEnumerable(
                Points.Select(p => new DataPoint { X = p.Point.X, Y = p.Point.Y })
            );
            // Pipeline: assemble features and train
            var pipeline = mlContext.Transforms.Concatenate("Features", nameof(DataPoint.X), nameof(DataPoint.Y))
                .Append(mlContext.Clustering.Trainers.KMeans(new KMeansTrainer.Options
                {
                    FeatureColumnName = "Features",
                    NumberOfClusters = ClusterCount,
                    MaximumNumberOfIterations = MaxIterations
                }));

            // Train model
            var model = pipeline.Fit(data);
            // Predict cluster assignments
            var predictions = model.Transform(data);
            var preds = mlContext.Data.CreateEnumerable<Prediction>(predictions, reuseRowObject: false).ToArray();

            // Build clusters
            Clusters = Enumerable.Range(0, ClusterCount)
                .Select(_ => new List<PointFWithContext<T>>())
                .ToList();
            for (int i = 0; i < Points.Count; i++)
            {
                // PredictedLabel is 1-based
                int clusterId = (int)preds[i].PredictedLabel - 1;
                Clusters[clusterId].Add(Points[i]);
            }
        }

        /// <summary>
        /// Executes minibatch K-Means by training on random subsets via ML.NET.
        /// </summary>
        /// <param name="batchSize">The number of points sampled per minibatch iteration; must be a positive integer.</param>
        /// <exception cref="InvalidOperationException">
        /// Thrown when <see cref="ClusterCount"/> is less than 1 or when there are fewer points than clusters.
        /// </exception>
        public void ExecuteMiniBatch(int batchSize = 5000)
        {
            if (ClusterCount < 1)
                throw new InvalidOperationException("ClusterCount must be at least 1.");
            if (Points.Count < ClusterCount)
                throw new InvalidOperationException("Not enough points to form the requested number of clusters.");

            var mlContext = new MLContext();
            // Initialize accumulator for centroids
            PointF[] centroids = null;

            var rnd = new Random();
            for (int iter = 0; iter < MaxIterations; iter++)
            {
                // Sample a minibatch
                var batch = Points.OrderBy(_ => rnd.Next()).Take(batchSize).ToList();
                var batchData = mlContext.Data.LoadFromEnumerable(
                    batch.Select(p => new DataPoint { X = p.Point.X, Y = p.Point.Y })
                );
                // Train on batch
                var pipe = mlContext.Transforms.Concatenate("Features", nameof(DataPoint.X), nameof(DataPoint.Y))
                    .Append(mlContext.Clustering.Trainers.KMeans(new KMeansTrainer.Options
                    {
                        FeatureColumnName = "Features",
                        NumberOfClusters = ClusterCount,
                        MaximumNumberOfIterations = 1
                    }));
                var model = pipe.Fit(batchData);
                var modelParams = model.LastTransformer.Model;
                // Extract centroids
                VBuffer<float>[] centroidBuffers = null;
                modelParams.GetClusterCentroids(ref centroidBuffers, out int k);
                var batchCentroids = centroidBuffers
                    .Take(k)
                    .Select(vb => vb.DenseValues().ToArray())
                    .Select(arr => new PointF(arr[0], arr[1]))
                    .ToArray();

                // Accumulate centroids
                if (centroids == null)
                {
                    centroids = batchCentroids;
                }
                else
                {
                    for (int c = 0; c < ClusterCount; c++)
                    {
                        // running average
                        centroids[c] = new PointF(
                            (centroids[c].X * iter + batchCentroids[c].X) / (iter + 1),
                            (centroids[c].Y * iter + batchCentroids[c].Y) / (iter + 1)
                        );
                    }
                }
            }

            // Assign points to final centroids
            Clusters = Enumerable.Range(0, ClusterCount)
                .Select(_ => new List<PointFWithContext<T>>())
                .ToList();
            for (int i = 0; i < Points.Count; i++)
            {
                var pt = Points[i].Point;
                int best = 0;
                float minDist = DistanceSquared(pt, centroids[0]);
                for (int c = 1; c < ClusterCount; c++)
                {
                    float d = DistanceSquared(pt, centroids[c]);
                    if (d < minDist)
                    {
                        minDist = d; best = c;
                    }
                }
                Clusters[best].Add(Points[i]);
            }
        }

        private static float DistanceSquared(PointF a, PointF b)
        {
            float dx = a.X - b.X;
            float dy = a.Y - b.Y;
            return dx * dx + dy * dy;
        }

        // ML.NET data structures
        private class DataPoint
        {
            [LoadColumn(0)] public float X { get; set; }
            [LoadColumn(1)] public float Y { get; set; }
        }
        private class Prediction
        {
            [ColumnName("PredictedLabel")] public uint PredictedLabel { get; set; }
        }
    }
}
